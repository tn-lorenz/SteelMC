//! Entity data synchronization system.
//!
//! This module provides the infrastructure for syncing entity state (health, pose, flags, etc.)
//! between server and client via the `SetEntityData` packet.
//!
//! # Architecture
//!
//! - [`SyncedValue<T>`] - Wrapper that tracks per-field dirty state
//! - [`EntityData`] - Type-erased enum for network serialization
//! - [`DataValue`] - Network-ready value with index and serializer info
//! - [`EntityPose`] - Entity pose states (standing, sneaking, swimming, etc.)
//! - [`EntityDataSerializerRegistry`] - Registry of serializers with writers
//!
//! # Serialization Flow
//!
//! Serialization happens through the registry, not directly on `EntityData`:
//! ```ignore
//! let writer = REGISTRY.entity_data_serializers.get_writer(serializer_id).unwrap();
//! writer(&entity_data_value, &mut buf)?;
//! ```
//!
//! # Generated Code
//!
//! Per-entity data structs (e.g., `PlayerEntityData`) are generated by the build script
//! from `entities.json` and live in `steel-registry/src/generated/entity_data.rs`.

mod serializer;
mod vanilla_serializers;

pub use serializer::{EntityDataSerializerEntry, EntityDataSerializerRegistry, EntityDataWriter};
pub use vanilla_serializers::register_vanilla_entity_data_serializers;

use std::{io, str::FromStr};

use steel_utils::{BlockStateId, Identifier, codec::VarInt, serial::WriteTo};
use text_components::TextComponent;
use uuid::Uuid;

use crate::item_stack::ItemStack;

// Re-export types used in generated code
pub use crate::blocks::properties::Direction;
pub use steel_utils::BlockPos;

/// Wrapper that tracks modifications per-field.
///
/// Each field in an entity data struct is wrapped in `SyncedValue` to track
/// whether it has been modified and needs to be synced to clients.
#[derive(Debug, Clone)]
pub struct SyncedValue<T> {
    value: T,
    default: T,
    dirty: bool,
}

impl<T: Clone + PartialEq> SyncedValue<T> {
    /// Create a new synced value with the given default.
    pub fn new(default: T) -> Self {
        Self {
            value: default.clone(),
            default,
            dirty: false,
        }
    }

    /// Get a reference to the current value.
    #[inline]
    pub fn get(&self) -> &T {
        &self.value
    }

    /// Set the value. Only marks as dirty if the value actually changed.
    #[inline]
    pub fn set(&mut self, value: T) {
        if self.value != value {
            self.value = value;
            self.dirty = true;
        }
    }

    /// Returns true if the value has been modified since last sync.
    #[inline]
    pub fn is_dirty(&self) -> bool {
        self.dirty
    }

    /// Clear the dirty flag after syncing.
    #[inline]
    pub fn clear_dirty(&mut self) {
        self.dirty = false;
    }

    /// Returns true if the current value equals the default.
    #[inline]
    pub fn is_default(&self) -> bool {
        self.value == self.default
    }
}

/// Entity pose states.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[repr(u8)]
pub enum EntityPose {
    #[default]
    Standing = 0,
    FallFlying = 1,
    Sleeping = 2,
    Swimming = 3,
    SpinAttack = 4,
    Sneaking = 5,
    LongJumping = 6,
    Dying = 7,
    Croaking = 8,
    UsingTongue = 9,
    Sitting = 10,
    Roaring = 11,
    Sniffing = 12,
    Emerging = 13,
    Digging = 14,
    Sliding = 15,
    Shooting = 16,
    Inhaling = 17,
}

impl FromStr for EntityPose {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "STANDING" => Ok(Self::Standing),
            "FALL_FLYING" => Ok(Self::FallFlying),
            "SLEEPING" => Ok(Self::Sleeping),
            "SWIMMING" => Ok(Self::Swimming),
            "SPIN_ATTACK" => Ok(Self::SpinAttack),
            "SNEAKING" | "CROUCHING" => Ok(Self::Sneaking),
            "LONG_JUMPING" => Ok(Self::LongJumping),
            "DYING" => Ok(Self::Dying),
            "CROAKING" => Ok(Self::Croaking),
            "USING_TONGUE" => Ok(Self::UsingTongue),
            "SITTING" => Ok(Self::Sitting),
            "ROARING" => Ok(Self::Roaring),
            "SNIFFING" => Ok(Self::Sniffing),
            "EMERGING" => Ok(Self::Emerging),
            "DIGGING" => Ok(Self::Digging),
            "SLIDING" => Ok(Self::Sliding),
            "SHOOTING" => Ok(Self::Shooting),
            "INHALING" => Ok(Self::Inhaling),
            _ => Err(()),
        }
    }
}

/// Rotations for armor stands and similar entities (pitch, yaw, roll in degrees).
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Rotations {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Rotations {
    pub const ZERO: Self = Self {
        x: 0.0,
        y: 0.0,
        z: 0.0,
    };

    pub fn new(x: f32, y: f32, z: f32) -> Self {
        Self { x, y, z }
    }
}

/// Main hand preference (left or right).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[repr(u8)]
pub enum HumanoidArm {
    Left = 0,
    #[default]
    Right = 1,
}

/// Villager profession, type, and level data.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct VillagerData {
    /// Villager type (biome variant) - registry ID.
    pub villager_type: i32,
    /// Profession - registry ID.
    pub profession: i32,
    /// Trading level (1-5).
    pub level: i32,
}

impl VillagerData {
    pub fn new(villager_type: i32, profession: i32, level: i32) -> Self {
        Self {
            villager_type,
            profession,
            level,
        }
    }
}

/// A global position (dimension + block position).
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlobalPos {
    pub dimension: Identifier,
    pub pos: BlockPos,
}

impl GlobalPos {
    pub fn new(dimension: Identifier, pos: BlockPos) -> Self {
        Self { dimension, pos }
    }
}

/// A 3D vector (for display entities).
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vector3f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Vector3f {
    pub const ZERO: Self = Self {
        x: 0.0,
        y: 0.0,
        z: 0.0,
    };

    pub fn new(x: f32, y: f32, z: f32) -> Self {
        Self { x, y, z }
    }
}

/// A quaternion rotation (for display entities).
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Quaternionf {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl Quaternionf {
    pub const IDENTITY: Self = Self {
        x: 0.0,
        y: 0.0,
        z: 0.0,
        w: 1.0,
    };

    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Self {
        Self { x, y, z, w }
    }
}

/// Particle effect data.
// TODO: Implement proper particle types when needed
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ParticleData {
    /// Particle type registry ID.
    pub particle_type: i32,
    // TODO: Add particle-specific options
}

/// A list of particle effects.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ParticleList {
    pub particles: Vec<ParticleData>,
}

/// Game profile for player heads and similar.
// TODO: Implement proper profile with UUID, name, and properties
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResolvableProfile {
    // TODO: Add fields when needed
}

/// Sniffer entity state.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[repr(u8)]
pub enum SnifferState {
    #[default]
    Idling = 0,
    FeelingHappy = 1,
    Scenting = 2,
    Sniffing = 3,
    Searching = 4,
    Digging = 5,
    Rising = 6,
}

/// Armadillo entity state.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[repr(u8)]
pub enum ArmadilloState {
    #[default]
    Idle = 0,
    RollingUp = 1,
    Rolled = 2,
    Unrolling = 3,
    Scared = 4,
}

/// Type-erased entity data for network encoding.
///
/// This enum holds the actual value to be sent over the network.
/// Serialization happens through the [`EntityDataSerializerRegistry`], not directly
/// on this type. Use `REGISTRY.entity_data_serializers.get_writer(id)` to get the
/// writer function for a specific serializer ID.
#[derive(Debug, Clone)]
pub enum EntityData {
    // Primitive types
    Byte(i8),
    Int(i32),
    Long(i64),
    Float(f32),
    String(String),
    Boolean(bool),

    // Text components
    Component(Box<TextComponent>),
    OptionalComponent(Option<Box<TextComponent>>),

    // Item
    ItemStack(ItemStack),

    // Spatial types
    Rotations(Rotations),
    BlockPos(BlockPos),
    OptionalBlockPos(Option<BlockPos>),
    Direction(Direction),
    OptionalLivingEntityRef(Option<Uuid>),
    BlockState(BlockStateId),
    OptionalBlockState(Option<BlockStateId>),
    Vector3(Vector3f),
    Quaternion(Quaternionf),

    // Entity states
    Pose(EntityPose),
    SnifferState(SnifferState),
    ArmadilloState(ArmadilloState),

    // Particles
    Particle(ParticleData),
    Particles(ParticleList),

    // Villager
    VillagerData(VillagerData),

    // Optional numeric
    OptionalUnsignedInt(Option<u32>),

    // Holder/registry reference variants (VarInt registry IDs)
    CatVariant(i32),
    CowVariant(i32),
    WolfVariant(i32),
    WolfSoundVariant(i32),
    FrogVariant(i32),
    PigVariant(i32),
    ChickenVariant(i32),
    ZombieNautilusVariant(i32),
    PaintingVariant(i32),

    // Global position
    OptionalGlobalPos(Option<GlobalPos>),

    // Copper golem / weathering states (future entities)
    CopperGolemState(i32),
    WeatheringCopperState(i32),

    // Profile
    ResolvableProfile(ResolvableProfile),

    // Player
    HumanoidArm(HumanoidArm),
}

/// Network-ready data value with index and serializer info.
///
/// This is what gets written to the `SetEntityData` packet.
#[derive(Debug, Clone)]
pub struct DataValue {
    /// The index of this data field (0-254, 255 is terminator).
    pub index: u8,
    /// The serializer ID (from registration order in EntityDataSerializerRegistry).
    pub serializer_id: i32,
    /// The actual value to write.
    pub value: EntityData,
}

impl DataValue {
    /// Write this data value to the buffer (without terminator).
    ///
    /// Uses the global registry to look up the writer function for this serializer.
    pub fn write_to(&self, buf: &mut Vec<u8>) -> io::Result<()> {
        use crate::REGISTRY;

        self.index.write(buf)?;
        VarInt(self.serializer_id).write(buf)?;

        let writer = REGISTRY
            .entity_data_serializers
            .get_writer(self.serializer_id)
            .ok_or_else(|| {
                io::Error::other(format!(
                    "Unknown entity data serializer ID: {}",
                    self.serializer_id
                ))
            })?;

        writer(&self.value, buf)
    }
}

/// Write a list of data values to a buffer, with the 0xFF terminator.
pub fn write_data_values(values: &[DataValue], buf: &mut Vec<u8>) -> io::Result<()> {
    for value in values {
        value.write_to(buf)?;
    }
    // Write terminator
    0xFFu8.write(buf)
}
